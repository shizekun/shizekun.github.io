<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/21/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/21/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">title:模块的加载机制<br>categories:<br><span class="hljs-bullet">- </span>1.模块的加载机制<br><span class="hljs-bullet">- </span>2.内置模块的加载机制<br><span class="hljs-bullet">- </span>3.自定义模块的加载机制<br><span class="hljs-bullet">- </span>4.第三方模块的加载机制<br></code></pre></td></tr></table></figure><h4 id="1-模块的加载机制"><a href="#1-模块的加载机制" class="headerlink" title="1.模块的加载机制"></a>1.模块的加载机制</h4><p><strong>模块在第一次加载后会被缓存</strong>。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。<br>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而<strong>提高模块的加载效率</strong>。</p><h4 id="2-内置模块的加载机制"><a href="#2-内置模块的加载机制" class="headerlink" title="2.内置模块的加载机制"></a>2.内置模块的加载机制</h4><p>内置模块是由Node.js 官方提供的模块，内置模块的加载优先级最高。</p><p>例如，require(‘fs’) 始终返回内置的fs 模块，即使在 node_modules 目录下有相同名字的包也叫作 fs。</p><h4 id="3-自定义模块的加载机制"><a href="#3-自定义模块的加载机制" class="headerlink" title="3.自定义模块的加载机制"></a>3.自定义模块的加载机制</h4><p>使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的<strong>路径标识符</strong>。在加载自定义模块时，如果没有指定 ./ 或 ../这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p><h4 id="4-第三方模块的加载机制"><a href="#4-第三方模块的加载机制" class="headerlink" title="4.第三方模块的加载机制"></a>4.第三方模块的加载机制</h4><p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父<br>目录开始，尝试从 /node_modules 文件夹中加载第三方模块。<br>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。<br>例如，假设在 ‘C:\Users\itheima\project\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：<br>① C:\Users\itheima\project\node_modules\tools<br>② C:\Users\itheima\node_modules\tools<br>③ C:\Users\node_modules\tools<br>④ C:\node_modules\tools</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：<br>① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口<br>② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。<br>③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/21/npm%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/21/npm%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">title:</span>npm相关命令<br><span class="hljs-symbol">categories:</span><br>- npm 笔记<br></code></pre></td></tr></table></figure><h4 id="1-包管理器"><a href="#1-包管理器" class="headerlink" title="1.包管理器"></a>1.包管理器</h4><p>Node.js 使用一款 npm 包管理器来管理所有的第三方包</p><p>在 npm 网站上搜索你想要的包：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><p>在 npm 上下载包： <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><h4 id="2-npm的一些常用命令"><a href="#2-npm的一些常用命令" class="headerlink" title="2.npm的一些常用命令"></a>2.npm的一些常用命令</h4><p>npm  -v   ：查看在自己电脑本机的npm</p><p>npm  i  包的具体名称    ：下载一个指定的包</p><p>npm  view  包的具体名称  ： 查看一个指定包</p><p>npm  i  包的具体名称@版本号  ：下载指定版本的包</p><p>npm init -y   :快速创建包管理配置文件(<strong>在项目的根目录下执行此命令</strong>)</p><p>npm install  :其他项目成员在执行此命令时，会自动根据 package.json 文件中记录的包名称和版本信息全部进行下载</p><h6 id="npm-uninstall-包名称-：-卸载指定的包"><a href="#npm-uninstall-包名称-：-卸载指定的包" class="headerlink" title="npm uninstall 包名称 ： 卸载指定的包"></a>npm uninstall 包名称 ： 卸载指定的包</h6><p>注意：</p><p>1.当命令执行成功后， dependencies 配置项下的包会自动移除</p><p>2.卸载包的时候不需要指定版本号</p><p> devDependencies 配置作用 </p><p>​      只在本地开发测试阶段需要用到的包，一般记录在 devDependencies 配置项中，后期在进行项目打包上线的</p><p>​    时候，并不会把这些包携带到线上环境</p><p>​      <code>npm i --save-dev 包名称@版本号</code> 或 <code>npm i -D 包名称@版本号</code> ：   安装开发测试阶段用到的包</p><p>npm config set registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> ：更换国内的源</p><p>npm config get registry  ：检查源有没有更换成功</p><p>借助cnpm 这个包，提供了下载命令<strong>cnpm i</strong> 包名称</p><p>npm  i -g nrm   =&gt; nrm ls =&gt;nrm use taobao</p><h4 id="3-npm-的包从作用域上可以分为："><a href="#3-npm-的包从作用域上可以分为：" class="headerlink" title="3.npm 的包从作用域上可以分为："></a>3.npm 的包从作用域上可以分为：</h4><ol><li>项目包： 被安装到项目的 node_modules 目录中的包，只能在当前项目下进行使用</li></ol><p>​      - [核心依赖包] 线上环境用到的依赖包： npm i 包名称</p><p>​      - [开发依赖包] 开发测试环境用到的依赖包：npm i -D 包名称</p><p>​    2. 全局包： 被下载到 node 安装位置 node_modules 目录下的包，可以在全局范围(任意目录)内使用</p><p>​      安装命令： npm i -g 包名称</p><p>​      卸载命令： npm uninstall -g 包名称</p><h4 id="4-使用一个把-markdown-格式的文档转成-html-格式文件的工具包"><a href="#4-使用一个把-markdown-格式的文档转成-html-格式文件的工具包" class="headerlink" title="4.使用一个把 markdown 格式的文档转成 html 格式文件的工具包"></a>4.使用一个把 markdown 格式的文档转成 html 格式文件的工具包</h4><p>​    1. 安装全局包： npm i -g i5ting_toc </p><ol start="2"><li>使用全局命令： <code>i5ting_toc -f 要转换的md文件 index.html</code></li></ol><h4 id="5-发布包的步骤"><a href="#5-发布包的步骤" class="headerlink" title="5.发布包的步骤:"></a>5.发布包的步骤:</h4><p>​      1. 编写包的说明文档 </p><p>​      在包的根目录下添加文件 README.md 文件</p><p>​      2. 注册一个 npm 账号</p><p>​      打开注册网址: <a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a></p><p>​      3. pc端打开注册邮箱进行确认</p><p>​      点击蓝色按钮 Verify Email</p><p>​      4. 在包的发布目录下面执行命令</p><p>​      <code>npm publish</code></p><p>​      5. 删除已经发布的包</p><p>​      <code>npm unpublish 包名称 --force</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/09/js%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/09/js%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title:JS高级-对象与面向对象<br>categories:<br>- JS笔记<br><span class="hljs-keyword">tags:</span><br>- JavaScript<br>- 面向过程与面向对象<br></code></pre></td></tr></table></figure><h3 id="JavaScript高级第01天笔记"><a href="#JavaScript高级第01天笔记" class="headerlink" title="JavaScript高级第01天笔记"></a>JavaScript高级第01天笔记</h3><h4 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h4><h4 id="1-1面向过程"><a href="#1-1面向过程" class="headerlink" title="1.1面向过程"></a>1.1面向过程</h4><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，<br>使用的时候再一个一个的依次调用就可以了。</p><h4 id="1-2面向对象"><a href="#1-2面向对象" class="headerlink" title="1.2面向对象"></a>1.2面向对象</h4><p>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><h4 id="1-3面向过程与面向对象对比"><a href="#1-3面向过程与面向对象对比" class="headerlink" title="1.3面向过程与面向对象对比"></a>1.3面向过程与面向对象对比</h4><h6 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h6><p>优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</p><p>缺点：不易维护、不易复用、不易扩展</p><h6 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h6><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，</p><p>使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><h3 id="2-对象与类"><a href="#2-对象与类" class="headerlink" title="2.对象与类"></a>2.对象与类</h3><h5 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h5><p>对象是由属性和方法组成的：是一个无序键值对 的集合，指的是一个具体的事物</p><p>属性：事物的特征，在对象中用属性来表示（常用名词）<br>方法：事物的行为，在对象中用方法来表示（常用动词）</p><h5 id="2-2类"><a href="#2-2类" class="headerlink" title="2.2类"></a>2.2类</h5><p> ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实<br>例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，<br>通过类实例化一个具体的对象</p><h5 id="2-2-1创建类"><a href="#2-2-1创建类" class="headerlink" title="2.2.1创建类"></a>2.2.1创建类</h5><ol><li><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//步骤1 使用class关键字</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span> </span>&#123;<br><span class="hljs-comment">// class body</span><br>&#125;<br><span class="hljs-comment">//步骤2使用定义的类创建实例 注意new关键字</span><br><span class="hljs-keyword">var</span> xx = <span class="hljs-keyword">new</span> name();<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class 创建一个 明星类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br><span class="hljs-comment">// 类的共有属性放到 constructor 里面</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh);<br><br></code></pre></td></tr></table></figure><h6 id="2-2-2类创建添加属性和方法"><a href="#2-2-2类创建添加属性和方法" class="headerlink" title="2.2.2类创建添加属性和方法"></a>2.2.2类创建添加属性和方法</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class 创建一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br><span class="hljs-comment">// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">uname, age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.uname = uname;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<span class="hljs-comment">//‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;注意,方法与方法之间不需</span><br>要添加逗号<br><span class="hljs-function"><span class="hljs-title">sing</span>(<span class="hljs-params">song</span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.uname + <span class="hljs-string">&#x27;唱&#x27;</span> + song);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span><br>ldh.sing(<span class="hljs-string">&#x27;冰雨&#x27;</span>); <span class="hljs-comment">// 刘德华唱冰雨</span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li><li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个<br>函数,类也会自动生成这个函数</li><li>多个函数方法之间不需要添加逗号分隔</li><li>生成实例 new 不能省略</li><li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需<br>要加function</li></ol><h5 id="2-2-3类的继承"><a href="#2-2-3类的继承" class="headerlink" title="2.2.3类的继承"></a>2.2.3类的继承</h5><ol><li><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>&#125;<br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">surname</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.surname= surname;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你的姓是&#x27;</span> + <span class="hljs-built_in">this</span>.surname);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span><br>&#125;<br><span class="hljs-keyword">var</span> damao= <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘&#x27;</span>);<br>damao.say(); <span class="hljs-comment">//结果为 你的姓是刘</span><br><br></code></pre></td></tr></table></figure><h6 id="子类使用super关键字访问父类的方法"><a href="#子类使用super关键字访问父类的方法" class="headerlink" title="子类使用super关键字访问父类的方法:"></a>子类使用super关键字访问父类的方法:</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义了父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-comment">//子元素继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">//使用super调用了父类中的构造函数</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>son.sum(); <span class="hljs-comment">//结果为3</span><br></code></pre></td></tr></table></figure><p>注意:</p><ol><li>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行<br>子类的</li><li>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这<br>个方法(就近原则)</li><li>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用<br>父类的构造函数,super 必须在子类this之前调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类有加法方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 子类继承父类加法方法 同时 扩展减法方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-comment">// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到</span><br><span class="hljs-built_in">this</span>之后会报错<br><span class="hljs-built_in">super</span>(x, y);<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">subtract</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x ‐ <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>son.subtract(); <span class="hljs-comment">//2</span><br>son.sum();<span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure><p>结果为：</p><p>2</p><p>8</p><ol start="4"><li>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</li><li>constructor中的this指向的是new出来的实例对象</li><li>自定义的方法,一般也指向的new出来的实例对象</li><li>绑定事件之后this指向的就是触发事件的事件源</li><li><strong>在 ES6 中类没有变量提升，**</strong>所以必须先定义类，才能通过类实例化对象**</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/09/hello-world/"/>
    <url>/2021/02/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
