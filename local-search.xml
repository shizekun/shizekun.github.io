<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>session的认证方案</title>
    <link href="/2021/02/27/session%E5%92%8Cjwt%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88/"/>
    <url>/2021/02/27/session%E5%92%8Cjwt%E7%9A%84%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h4 id="session的认证方案："><a href="#session的认证方案：" class="headerlink" title="session的认证方案："></a>session的认证方案：</h4><p>1.安装 express-session中间件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> insrall express-session<br></code></pre></td></tr></table></figure><p>2.配置 express-session 中间件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//1.</span> <span class="hljs-string">导入</span> <span class="hljs-string">session</span> <span class="hljs-string">中间件</span><br><span class="hljs-string">const</span> <span class="hljs-string">session</span> <span class="hljs-string">=</span> <span class="hljs-string">require(&#x27;express-session&#x27;)</span><br><br><span class="hljs-string">//2.配置</span> <span class="hljs-string">Session</span> <span class="hljs-string">中间件</span><br><span class="hljs-string">app.use(session(&#123;</span><br>  <span class="hljs-attr">secret:</span> <span class="hljs-string">&#x27;keyboard cat&#x27;</span><span class="hljs-string">,</span><br>  <span class="hljs-attr">resave:</span> <span class="hljs-literal">false</span><span class="hljs-string">,</span><br>  <span class="hljs-attr">saveUninitialized:</span> <span class="hljs-literal">true</span><span class="hljs-string">,</span><br>  <span class="hljs-attr">cookie:</span> &#123; <span class="hljs-attr">secure:</span> <span class="hljs-literal">true</span> &#125;<br><span class="hljs-string">&#125;))</span><br><br></code></pre></td></tr></table></figure><p>3.向 session 中存数据</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 登录的 API 接口</span><br><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.post</span>(<span class="hljs-string">&#x27;/api/login&#x27;</span>, (req, res) =&gt; &#123;<br>  <span class="hljs-comment">// 判断用户提交的登录信息是否正确</span><br>  <span class="hljs-selector-tag">if</span> (req.body.username !== <span class="hljs-string">&#x27;admin&#x27;</span> || req.body.password !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.send</span>(&#123; <span class="hljs-attribute">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attribute">msg</span>: <span class="hljs-string">&#x27;登录失败&#x27;</span> &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// TODO_02：请将登录成功后的用户信息，保存到 Session 中</span><br>  <span class="hljs-comment">// req.body 获取请求体中的数据&#123; username: &#x27;admin&#x27;, password: &#x27;00000&#x27; &#125;</span><br>  req.session.user = req.body<br>  req.session.isLogin = true<br><br>  res.send(&#123; <span class="hljs-attribute">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">msg</span>: <span class="hljs-string">&#x27;登录成功&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><ol start="4"><li>从 session 中取数据</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 获取用户姓名的接口</span><br><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.get</span>(<span class="hljs-string">&#x27;/api/username&#x27;</span>, (req, res) =&gt; &#123;<br>  <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(req.session.isLogin)<br>  <span class="hljs-comment">// TODO_03：请从 Session 中获取用户的名称，响应给客户端</span><br>  <span class="hljs-selector-tag">if</span> (req.session.isLogin != true) &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.send</span>(&#123; <span class="hljs-attribute">status</span>: <span class="hljs-number">1</span>, <span class="hljs-attribute">message</span>: <span class="hljs-string">&#x27;没有登录！&#x27;</span> &#125;)<br>  &#125;<br>  res.send(&#123; <span class="hljs-attribute">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">message</span>: <span class="hljs-string">&#x27;获取用户名成功&#x27;</span>, <span class="hljs-attribute">username</span>: req.session.user.username &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>5.清空session</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 退出登录的接口</span><br><span class="hljs-selector-tag">app</span><span class="hljs-selector-class">.post</span>(<span class="hljs-string">&#x27;/api/logout&#x27;</span>, (req, res) =&gt; &#123;<br>  <span class="hljs-comment">// TODO_04：清空 Session 信息</span><br>  <span class="hljs-selector-tag">req</span><span class="hljs-selector-class">.session</span><span class="hljs-selector-class">.destroy</span>()<br>  <span class="hljs-comment">// 返回退出成功</span><br>  <span class="hljs-selector-tag">res</span><span class="hljs-selector-class">.send</span>(&#123; <span class="hljs-attribute">status</span>: <span class="hljs-number">0</span>, <span class="hljs-attribute">message</span>: <span class="hljs-string">&#x27;退出成功&#x27;</span> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h6 id="了解-Session-认证的局限性"><a href="#了解-Session-认证的局限性" class="headerlink" title="了解 Session 认证的局限性"></a>了解 Session 认证的局限性</h6><p>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及前端跨域请求后端接口<br>的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</p><p>注意：</p><p>⚫ 当前端请求后端接口<strong>不存在跨域问题</strong>的时候，<strong>推荐使用 Session</strong> 身份认证机制。<br>⚫ 当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制。</p><h4 id="JWT-认证机制"><a href="#JWT-认证机制" class="headerlink" title="JWT 认证机制:"></a>JWT 认证机制:</h4><p>JWT（英文全称：JSON Web Token）是目前最流行的<strong>跨域认证解决方案</strong>。</p><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。</p><p>JWT 通常由三部分组成，分别是 Header（头部）、Payload（有效荷载）、Signature（签名）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Header</span><span class="hljs-selector-class">.Payload</span><span class="hljs-selector-class">.Signature</span><br></code></pre></td></tr></table></figure><p>⚫ Payload 部分才是真正的用户信息，它是用户信息经过加密之后生成的字符串。<br>⚫ Header 和 Signature 是安全性相关的部分，只是为了保证 Token 的安全性</p><p>JWT 的使用方式:</p><p>客户端收到服务器返回的 JWT 之后，通常会将它储存在 localStorage 或 sessionStorage 中。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。推荐的做法是把 <strong>JWT 放在 HTTP 请求头的 Authorization 字段中</strong>，格式如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">Authorization:</span>Bearer <span class="hljs-params">&lt;token&gt;</span><br></code></pre></td></tr></table></figure><p>1.安装jwt相关的包</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">jsonwebtoken </span>express-<span class="hljs-keyword">jwt</span><br></code></pre></td></tr></table></figure><p>其中：</p><p>⚫ jsonwebtoken 用于生成 JWT 字符串<br>⚫ express-jwt 用于将 JWT 字符串解析还原成 JSON 对象</p><p>2.导入JWT包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// TODO_01：安装并导入 JWT 相关的两个包，分别是 jsonwebtoken 和 express-jwt</span><br><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;jsonwebtoken&#x27;</span>)<br><span class="hljs-keyword">const</span> jwtParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-jwt&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li>定义 secret 密钥</li></ol><p>为了保证 <strong>JWT 字符串的安全性</strong>，防止 JWT 字符串在网络传输过程中被别人破解，我们需要专门定义一个用于加密和解密<br>的 secret 密钥：<br>① 当生成 JWT 字符串的时候，需要使用 secret 密钥对用户的信息进行加密，最终得到加密好的 JWT 字符串<br>② 当把 JWT 字符串解析还原成 JSON 对象的时候，需要使用 secret 密钥进行解密</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// secret 密钥的本质：就是一个字符串</span><br><span class="hljs-keyword">const</span> secretKey=<span class="hljs-string">&#x27;^_^  ^_^&#x27;</span><br></code></pre></td></tr></table></figure><p>4.在登录成功后生成JWT字符串</p><p>调用 jsonwebtoken 包提供的 <strong>sign()</strong> 方法，将用户的信息加密成 JWT 字符串，响应给客户端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 登录接口</span><br>app.post(<span class="hljs-string">&#x27;/api/login&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>  <span class="hljs-comment">// 将 req.body 请求体中的数据，转存为 userinfo 常量</span><br>  <span class="hljs-keyword">const</span> userinfo = req.body<br>  <span class="hljs-comment">// 登录失败</span><br>  <span class="hljs-keyword">if</span> (userinfo.username !== <span class="hljs-string">&#x27;admin&#x27;</span> || userinfo.password !== <span class="hljs-string">&#x27;000000&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> res.send(&#123;<br>      status: <span class="hljs-number">400</span>,<br>      message: <span class="hljs-string">&#x27;登录失败！&#x27;</span><br>    &#125;)<br>  &#125;<br>  res.send(&#123;<br>    status: <span class="hljs-number">200</span>,<br>    message: <span class="hljs-string">&#x27;登录成功！&#x27;</span>,<br>    token: jwt.sign(&#123; <span class="hljs-attr">username</span>: userinfo.username &#125;, secretKey, &#123; <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">&#x27;30s&#x27;</span> &#125;)<br>  &#125;)<br>  <span class="hljs-comment">// 登录成功</span><br>  <span class="hljs-comment">// TODO_03：在登录成功之后，调用 jwt.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端</span><br><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="5"><li>注册将 <strong>JWT 字符串还原为 JSON 对象</strong>的中间件</li><li>客户端每次在访问那些有权限接口的时候，都需要主动通过请求头中的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证。</li></ol><p>此时，服务器可以通过 express-jwt 这个中间件，自动将客户端发送过来的 Token 解析还原成 JSON 对象：</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL和JWT 的基本使用</title>
    <link href="/2021/02/24/MYSQL%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/"/>
    <url>/2021/02/24/MYSQL%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="DataType-数据类型："><a href="#DataType-数据类型：" class="headerlink" title="DataType 数据类型："></a>DataType 数据类型：</h3><p>int    整数</p><p>varchar(len)    字符串</p><p>tinyint(1)    布尔值</p><p>字段的特殊标识：</p><p>PK (Primary Key)    主键、唯一标识</p><p>NN (Not Null)    值不允许为空</p><p>UQ (Unique)        值唯一</p><p>AI (Auto Increment)    值自动增长</p><h4 id="1-使用-SQL-管理数据库"><a href="#1-使用-SQL-管理数据库" class="headerlink" title="1.使用 SQL 管理数据库"></a>1.使用 SQL 管理数据库</h4><p>使用SQL增、删、改、查：</p><p>查询数据：<strong>select</strong></p><p>插入数据：<strong>insert into</strong></p><p>更改数据：<strong>update</strong></p><p>删除数据：<strong>delete</strong></p><p>需要掌握的SQL语法：</p><p>*<em>where条件、and和or运算符、order by 排序、count(</em>)函数**</p><p>使用例子：</p><p>– 查询users表中所有列的数据</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users<br></code></pre></td></tr></table></figure><p>– 从 users 表中查询指定 username 和 status 列的数据</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span>  username, status  <span class="hljs-keyword">from</span>  users<br></code></pre></td></tr></table></figure><p>– 向 users 表中插入一条数据 username 是 hutao，password 是 admin123</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span>  <span class="hljs-keyword">into</span>  users (username,<span class="hljs-keyword">password</span>) <span class="hljs-keyword">values</span>(hutao,admin123);<br></code></pre></td></tr></table></figure><p>– 修改 username 为 xm 的这条数据的密码，修改为abcdef</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update <span class="hljs-built_in"> users </span> <span class="hljs-builtin-name">set</span>  <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;abcdef&#x27;</span>  where  <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;xm&#x27;</span><br></code></pre></td></tr></table></figure><p>– 修改 username 为xm 的这条数据的密码，改为abcdef和 status改为1</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">update <span class="hljs-built_in"> users </span> <span class="hljs-builtin-name">set</span>  <span class="hljs-attribute">password</span>=<span class="hljs-string">&#x27;abcdef&#x27;</span>,status=1  where  <span class="hljs-attribute">username</span>=<span class="hljs-string">&#x27;xm&#x27;</span><br></code></pre></td></tr></table></figure><p>– 删除 users 表中id等于3 的那行数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">delete</span>  <span class="hljs-keyword">from</span>  users  <span class="hljs-keyword">where</span>  id=<span class="hljs-string">&#x27;3&#x27;</span><br></code></pre></td></tr></table></figure><p>– 查询表中id 不等于 5 的用户</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span>  *  <span class="hljs-keyword">from</span>  users  <span class="hljs-keyword">where</span>  id!=<span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>– 查询表中id 的值在 2到6之间的用户</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">select * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>– 查询表中 username 中带  ‘123’ 的用户</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users <span class="hljs-keyword">where</span> username <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模块的加载机制</title>
    <link href="/2021/02/21/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/02/21/%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="1-模块的加载机制"><a href="#1-模块的加载机制" class="headerlink" title="1.模块的加载机制"></a>1.模块的加载机制</h4><p><strong>模块在第一次加载后会被缓存</strong>。 这也意味着多次调用 require() 不会导致模块的代码被执行多次。<br>注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，从而<strong>提高模块的加载效率</strong>。</p><h4 id="2-内置模块的加载机制"><a href="#2-内置模块的加载机制" class="headerlink" title="2.内置模块的加载机制"></a>2.内置模块的加载机制</h4><p>内置模块是由Node.js 官方提供的模块，内置模块的加载优先级最高。</p><p>例如，require(‘fs’) 始终返回内置的fs 模块，即使在 node_modules 目录下有相同名字的包也叫作 fs。</p><h4 id="3-自定义模块的加载机制"><a href="#3-自定义模块的加载机制" class="headerlink" title="3.自定义模块的加载机制"></a>3.自定义模块的加载机制</h4><p>使用 require() 加载自定义模块时，必须指定以 ./ 或 ../ 开头的<strong>路径标识符</strong>。在加载自定义模块时，如果没有指定 ./ 或 ../这样的路径标识符，则 node 会把它当作内置模块或第三方模块进行加载。</p><h4 id="4-第三方模块的加载机制"><a href="#4-第三方模块的加载机制" class="headerlink" title="4.第三方模块的加载机制"></a>4.第三方模块的加载机制</h4><p>如果传递给 require() 的模块标识符不是一个内置模块，也没有以 ‘./’ 或 ‘../’ 开头，则 Node.js 会从当前模块的父<br>目录开始，尝试从 /node_modules 文件夹中加载第三方模块。<br>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。<br>例如，假设在 ‘C:\Users\itheima\project\foo.js’ 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：<br>① C:\Users\itheima\project\node_modules\tools<br>② C:\Users\itheima\node_modules\tools<br>③ C:\Users\node_modules\tools<br>④ C:\node_modules\tools</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>当把目录作为模块标识符，传递给 require() 进行加载的时候，有三种加载方式：<br>① 在被加载的目录下查找一个叫做 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口<br>② 如果目录里没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。<br>③ 如果以上两步都失败了，则 Node.js 会在终端打印错误消息，报告模块的缺失：Error: Cannot find module ‘xxx</p>]]></content>
    
    
    <categories>
      
      <category>1.模块的加载机制</category>
      
      <category>2.内置模块的加载机制</category>
      
      <category>3.自定义模块的加载机制</category>
      
      <category>4.第三方模块的加载机制</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm相关命令</title>
    <link href="/2021/02/21/npm%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/21/npm%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h4 id="1-包管理器"><a href="#1-包管理器" class="headerlink" title="1.包管理器"></a>1.包管理器</h4><p>Node.js 使用一款 npm 包管理器来管理所有的第三方包</p><p>在 npm 网站上搜索你想要的包：<a href="https://www.npmjs.com/">https://www.npmjs.com/</a></p><p>在 npm 上下载包： <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><h4 id="2-npm的一些常用命令"><a href="#2-npm的一些常用命令" class="headerlink" title="2.npm的一些常用命令"></a>2.npm的一些常用命令</h4><p>查看在自己电脑本机的npm:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span>  -v <br></code></pre></td></tr></table></figure><p>下载一个指定的包:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span>  i  包的具体名称  <br></code></pre></td></tr></table></figure><p>查看一个指定包</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span>  view  包的具体名称  <br></code></pre></td></tr></table></figure><p>下载指定版本的包:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span>  i  包的具体名称@版本号  <br></code></pre></td></tr></table></figure><p>快速创建包管理配置文件(<strong>在项目的根目录下执行此命令</strong>):</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init -y   <br></code></pre></td></tr></table></figure><p>其他项目成员在执行此命令时，会自动根据 package.json 文件中记录的包名称和版本信息全部进行下载:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span>  <br></code></pre></td></tr></table></figure><h6 id="卸载指定的包"><a href="#卸载指定的包" class="headerlink" title="卸载指定的包:"></a>卸载指定的包:</h6><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall 包名称<br></code></pre></td></tr></table></figure><p>注意：</p><p>1.当命令执行成功后， dependencies 配置项下的包会自动移除</p><p>2.卸载包的时候不需要指定版本号</p><p> devDependencies 配置作用 </p><p>​      只在本地开发测试阶段需要用到的包，一般记录在 devDependencies 配置项中，后期在进行项目打包上线的时候，并不会把这些包携带到线上环境.</p><p>   安装开发测试阶段用到的包:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i --save-dev 包名称@版本号 或 <span class="hljs-built_in">npm</span> i -D 包名称@版本号<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">registry</span>=https://registry.npm.taobao.org ：更换国内的源<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">get</span> registry  ：检查源有没有更换成功<br></code></pre></td></tr></table></figure><p>借助cnpm 这个包，提供了下载命令<strong>cnpm i</strong> 包名称</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-built_in">npm</span>  i -g nrm   =&gt; nrm ls =&gt;nrm use taobao<br></code></pre></td></tr></table></figure><h4 id="3-npm-的包从作用域上可以分为："><a href="#3-npm-的包从作用域上可以分为：" class="headerlink" title="3.npm 的包从作用域上可以分为："></a>3.npm 的包从作用域上可以分为：</h4><ol><li>项目包： 被安装到项目的 node_modules 目录中的包，只能在当前项目下进行使用</li></ol><p>​      - [核心依赖包] 线上环境用到的依赖包：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i 包名称<br></code></pre></td></tr></table></figure><p>​      - [开发依赖包] 开发测试环境用到的依赖包：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D 包名称<br></code></pre></td></tr></table></figure><p>​    2. 全局包： 被下载到 node 安装位置 node_modules 目录下的包，可以在全局范围(任意目录)内使用</p><p>​      安装命令：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g 包名称<br></code></pre></td></tr></table></figure><p>​      卸载命令：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall -g 包名称<br></code></pre></td></tr></table></figure><h4 id="4-使用一个把-markdown-格式的文档转成-html-格式文件的工具包"><a href="#4-使用一个把-markdown-格式的文档转成-html-格式文件的工具包" class="headerlink" title="4.使用一个把 markdown 格式的文档转成 html 格式文件的工具包"></a>4.使用一个把 markdown 格式的文档转成 html 格式文件的工具包</h4><p>​    1. 安装全局包 </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> i -g i<span class="hljs-number">5</span>ting_toc <br></code></pre></td></tr></table></figure><ol start="2"><li>使用全局命令：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">i5ting_toc <span class="hljs-operator">-f</span> 要转换的<span class="hljs-built_in">md</span>文件 index.html<br></code></pre></td></tr></table></figure><h4 id="5-发布包的步骤"><a href="#5-发布包的步骤" class="headerlink" title="5.发布包的步骤:"></a>5.发布包的步骤:</h4><p>​      1. 编写包的说明文档 </p><p>​      在包的根目录下添加文件 README.md 文件</p><p>​      2. 注册一个 npm 账号</p><p>​      打开注册网址: <a href="https://www.npmjs.com/signup">https://www.npmjs.com/signup</a></p><p>​      3. pc端打开注册邮箱进行确认</p><p>​      点击蓝色按钮 Verify Email</p><p>​      4. 在包的发布目录下面执行命令</p><p>​      <code>npm publish</code></p><p>​      5. 删除已经发布的包</p><p>​      <code>npm unpublish 包名称 --force</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS高级-对象与面向对象</title>
    <link href="/2021/02/09/js%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/09/js%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="JavaScript高级第01天笔记"><a href="#JavaScript高级第01天笔记" class="headerlink" title="JavaScript高级第01天笔记"></a>JavaScript高级第01天笔记</h3><h4 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h4><h4 id="1-1面向过程"><a href="#1-1面向过程" class="headerlink" title="1.1面向过程"></a>1.1面向过程</h4><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，<br>使用的时候再一个一个的依次调用就可以了。</p><h4 id="1-2面向对象"><a href="#1-2面向对象" class="headerlink" title="1.2面向对象"></a>1.2面向对象</h4><p>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><h4 id="1-3面向过程与面向对象对比"><a href="#1-3面向过程与面向对象对比" class="headerlink" title="1.3面向过程与面向对象对比"></a>1.3面向过程与面向对象对比</h4><h6 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h6><p>优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</p><p>缺点：不易维护、不易复用、不易扩展</p><h6 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h6><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，</p><p>使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><h3 id="2-对象与类"><a href="#2-对象与类" class="headerlink" title="2.对象与类"></a>2.对象与类</h3><h5 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h5><p>对象是由属性和方法组成的：是一个无序键值对 的集合，指的是一个具体的事物</p><p>属性：事物的特征，在对象中用属性来表示（常用名词）<br>方法：事物的行为，在对象中用方法来表示（常用动词）</p><h5 id="2-2类"><a href="#2-2类" class="headerlink" title="2.2类"></a>2.2类</h5><p> ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实<br>例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，<br>通过类实例化一个具体的对象</p><h5 id="2-2-1创建类"><a href="#2-2-1创建类" class="headerlink" title="2.2.1创建类"></a>2.2.1创建类</h5><ol><li><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//步骤1 使用class关键字</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span> </span>&#123;<br><span class="hljs-comment">// class body</span><br>&#125;<br><span class="hljs-comment">//步骤2使用定义的类创建实例 注意new关键字</span><br><span class="hljs-keyword">var</span> xx = <span class="hljs-keyword">new</span> name();<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class 创建一个 明星类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br><span class="hljs-comment">// 类的共有属性放到 constructor 里面</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh);<br><br></code></pre></td></tr></table></figure><h6 id="2-2-2类创建添加属性和方法"><a href="#2-2-2类创建添加属性和方法" class="headerlink" title="2.2.2类创建添加属性和方法"></a>2.2.2类创建添加属性和方法</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class 创建一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br><span class="hljs-comment">// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">uname, age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.uname = uname;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<span class="hljs-comment">//‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;注意,方法与方法之间不需</span><br>要添加逗号<br><span class="hljs-function"><span class="hljs-title">sing</span>(<span class="hljs-params">song</span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.uname + <span class="hljs-string">&#x27;唱&#x27;</span> + song);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span><br>ldh.sing(<span class="hljs-string">&#x27;冰雨&#x27;</span>); <span class="hljs-comment">// 刘德华唱冰雨</span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li><li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个<br>函数,类也会自动生成这个函数</li><li>多个函数方法之间不需要添加逗号分隔</li><li>生成实例 new 不能省略</li><li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需<br>要加function</li></ol><h5 id="2-2-3类的继承"><a href="#2-2-3类的继承" class="headerlink" title="2.2.3类的继承"></a>2.2.3类的继承</h5><ol><li><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>&#125;<br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">surname</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.surname= surname;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你的姓是&#x27;</span> + <span class="hljs-built_in">this</span>.surname);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span><br>&#125;<br><span class="hljs-keyword">var</span> damao= <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘&#x27;</span>);<br>damao.say(); <span class="hljs-comment">//结果为 你的姓是刘</span><br><br></code></pre></td></tr></table></figure><h6 id="子类使用super关键字访问父类的方法"><a href="#子类使用super关键字访问父类的方法" class="headerlink" title="子类使用super关键字访问父类的方法:"></a>子类使用super关键字访问父类的方法:</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义了父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-comment">//子元素继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">//使用super调用了父类中的构造函数</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>son.sum(); <span class="hljs-comment">//结果为3</span><br></code></pre></td></tr></table></figure><p>注意:</p><ol><li>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行<br>子类的</li><li>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这<br>个方法(就近原则)</li><li>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用<br>父类的构造函数,super 必须在子类this之前调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类有加法方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 子类继承父类加法方法 同时 扩展减法方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-comment">// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到</span><br><span class="hljs-built_in">this</span>之后会报错<br><span class="hljs-built_in">super</span>(x, y);<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">subtract</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x ‐ <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>son.subtract(); <span class="hljs-comment">//2</span><br>son.sum();<span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure><p>结果为：</p><ol start="4"><li>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</li><li>constructor中的this指向的是new出来的实例对象</li><li>自定义的方法,一般也指向的new出来的实例对象</li><li>绑定事件之后this指向的就是触发事件的事件源</li><li><strong>在 ES6 中类没有变量提升，**</strong>所以必须先定义类，才能通过类实例化对象**</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hello world</title>
    <link href="/2021/02/09/hello-world/"/>
    <url>/2021/02/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
