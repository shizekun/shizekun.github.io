<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/02/09/js%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2021/02/09/js%E9%AB%98%E7%BA%A7%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">title:JS高级-对象与面向对象<br>categories:<br>- JS笔记<br><span class="hljs-keyword">tags:</span><br>- JavaScript<br></code></pre></td></tr></table></figure><h3 id="JavaScript高级第01天笔记"><a href="#JavaScript高级第01天笔记" class="headerlink" title="JavaScript高级第01天笔记"></a>JavaScript高级第01天笔记</h3><h4 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1.面向过程与面向对象"></a>1.面向过程与面向对象</h4><h4 id="1-1面向过程"><a href="#1-1面向过程" class="headerlink" title="1.1面向过程"></a>1.1面向过程</h4><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，<br>使用的时候再一个一个的依次调用就可以了。</p><h4 id="1-2面向对象"><a href="#1-2面向对象" class="headerlink" title="1.2面向对象"></a>1.2面向对象</h4><p>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</p><h4 id="1-3面向过程与面向对象对比"><a href="#1-3面向过程与面向对象对比" class="headerlink" title="1.3面向过程与面向对象对比"></a>1.3面向过程与面向对象对比</h4><h6 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h6><p>优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</p><p>缺点：不易维护、不易复用、不易扩展</p><h6 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h6><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，</p><p>使系统更加灵活、更加易于维护</p><p>缺点：性能比面向过程低</p><h3 id="2-对象与类"><a href="#2-对象与类" class="headerlink" title="2.对象与类"></a>2.对象与类</h3><h5 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h5><p>对象是由属性和方法组成的：是一个无序键值对 的集合，指的是一个具体的事物</p><p>属性：事物的特征，在对象中用属性来表示（常用名词）<br>方法：事物的行为，在对象中用方法来表示（常用动词）</p><h5 id="2-2类"><a href="#2-2类" class="headerlink" title="2.2类"></a>2.2类</h5><p> ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实<br>例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，<br>通过类实例化一个具体的对象</p><h5 id="2-2-1创建类"><a href="#2-2-1创建类" class="headerlink" title="2.2.1创建类"></a>2.2.1创建类</h5><ol><li><p>语法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//步骤1 使用class关键字</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span> </span>&#123;<br><span class="hljs-comment">// class body</span><br>&#125;<br><span class="hljs-comment">//步骤2使用定义的类创建实例 注意new关键字</span><br><span class="hljs-keyword">var</span> xx = <span class="hljs-keyword">new</span> name();<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>示例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class 创建一个 明星类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br><span class="hljs-comment">// 类的共有属性放到 constructor 里面</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh);<br><br></code></pre></td></tr></table></figure><h6 id="2-2-2类创建添加属性和方法"><a href="#2-2-2类创建添加属性和方法" class="headerlink" title="2.2.2类创建添加属性和方法"></a>2.2.2类创建添加属性和方法</h6></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建类 class 创建一个类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br><span class="hljs-comment">// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数</span><br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">uname, age</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.uname = uname;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<span class="hljs-comment">//‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;注意,方法与方法之间不需</span><br>要添加逗号<br><span class="hljs-function"><span class="hljs-title">sing</span>(<span class="hljs-params">song</span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.uname + <span class="hljs-string">&#x27;唱&#x27;</span> + song);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 2. 利用类创建对象 new</span><br><span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-number">18</span>);<br><span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span><br>ldh.sing(<span class="hljs-string">&#x27;冰雨&#x27;</span>); <span class="hljs-comment">// 刘德华唱冰雨</span><br></code></pre></td></tr></table></figure><p>注意：</p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li><li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个<br>函数,类也会自动生成这个函数</li><li>多个函数方法之间不需要添加逗号分隔</li><li>生成实例 new 不能省略</li><li>语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需<br>要加function</li></ol><h5 id="2-2-3类的继承"><a href="#2-2-3类的继承" class="headerlink" title="2.2.3类的继承"></a>2.2.3类的继承</h5><ol><li><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<br>&#125;<br><span class="hljs-comment">// 子类继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>示例</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">surname</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.surname= surname;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;你的姓是&#x27;</span> + <span class="hljs-built_in">this</span>.surname);<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span><br>&#125;<br><span class="hljs-keyword">var</span> damao= <span class="hljs-keyword">new</span> Son(<span class="hljs-string">&#x27;刘&#x27;</span>);<br>damao.say(); <span class="hljs-comment">//结果为 你的姓是刘</span><br><br></code></pre></td></tr></table></figure><h6 id="子类使用super关键字访问父类的方法"><a href="#子类使用super关键字访问父类的方法" class="headerlink" title="子类使用super关键字访问父类的方法:"></a>子类使用super关键字访问父类的方法:</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//定义了父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-comment">//子元素继承父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">//使用super调用了父类中的构造函数</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>son.sum(); <span class="hljs-comment">//结果为3</span><br></code></pre></td></tr></table></figure><p>注意:</p><ol><li>继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行<br>子类的</li><li>继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这<br>个方法(就近原则)</li><li>如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用<br>父类的构造函数,super 必须在子类this之前调用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 父类有加法方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 子类继承父类加法方法 同时 扩展减法方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br><span class="hljs-comment">// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到</span><br><span class="hljs-built_in">this</span>之后会报错<br><span class="hljs-built_in">super</span>(x, y);<br><span class="hljs-built_in">this</span>.x = x;<br><span class="hljs-built_in">this</span>.y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">subtract</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x ‐ <span class="hljs-built_in">this</span>.y);<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<br>son.subtract(); <span class="hljs-comment">//2</span><br>son.sum();<span class="hljs-comment">//8</span><br></code></pre></td></tr></table></figure><p>结果为：</p><p>2</p><p>8</p><ol start="4"><li>时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</li><li>constructor中的this指向的是new出来的实例对象</li><li>自定义的方法,一般也指向的new出来的实例对象</li><li>绑定事件之后this指向的就是触发事件的事件源</li><li><strong>在 ES6 中类没有变量提升，**</strong>所以必须先定义类，才能通过类实例化对象**</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/02/09/hello-world/"/>
    <url>/2021/02/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
